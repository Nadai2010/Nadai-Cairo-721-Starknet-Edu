## Creación de atributos de token

* Llame a `ex2a_get_animal_rank()` para que le asignen una criatura aleatoria para crear.
* Lea las características esperadas de su animal del Evaluador.
* Cree las herramientas necesarias para registrar las características de los animales en su contrato y permita que el contrato del evaluador las recupere a través de la función `get_animal_characteristics` en su contrato [marque esto](https://github.com/starknet-edu/starknet-erc721/blob/main/contracts/IExerciseSolution.cairo).
* Implementa tu nuevo contrato.
* Acuñar el animal con las características deseadas y entregarlo al evaluador.
* Llame a `submit_exercise() `en el Evaluador para configurar el contrato que desea evaluar.
* Llame a e`x2b_test_declare_animal()` para recibir puntos (2 pts)

¿Buscas el ejercicio 1? Haga clic [aquí](https://github.com/Nadai2010/Nadai-Cairo-721-Starknet-Edu/blob/master/contracts/Soluci%C3%B3n/ERC721ex02.cairo)

## Solución

Comenzamos como sugiere el ejercicio llamando a la función `ex2a_get_animal_rank` del [Evaluador](https://goerli.voyager.online/contract/0x2d15a378e131b0a9dc323d0eae882bfe8ecc59de0eb206266ca236f823e0a15#writeContract) usando Voyager y Argent X.

![Graph](/contracts/Imagenes/getrangoex02.png)

## Creación de características aleatorias para NFT

Para saber qué características se generaron aleatoriamente, debemos llamar a las funciones de visualización `assigned_legs_number`, `assigned_sex_number` y `assigned_wings_number` del [Evaluador](https://goerli.voyager.online/contract/0x2d15a378e131b0a9dc323d0eae882bfe8ecc59de0eb206266ca236f823e0a15#readContract) proporcionando la dirección de nuestra cuenta de prueba en Argent X en este caso `0x05B23d29C5b33a1cf0c4e50F798f9E22c7254913368996436682852EfCF69f86`.

![Graph](/contracts/Imagenes/wingex02.png),![Graph](/contracts/Imagenes/legsex02.png),![Graph](/contracts/Imagenes/sexex02.png)

Número de alas asignado aleatoriamente para NFT
Número de alas asignado aleatoriamente para NFT
Después de verificar esas tres funciones, se nos informa que nuestro NFT que se creará próximamente debería haber asignado el número 2 para el sexo , 4 para las alas y 8 para las piernas . 

Antes de continuar con el ejercicio, usaré nuevamente el ERC721MintableBurnable.cairo de OpenZeppelin como base para nuestro contrato inteligente ERC721, así que simplemente copiaré el código en un nuevo archivo llamado ERC721_ex2.cairo dentro del carpeta src .

En este momento, la estructura de carpetas de nuestro proyecto debería verse así:

$ tree .
>>>
.
├── comp
│   └── ERC721_ex1.json
├── src
│   ├── ERC721_ex1.cairo
│   └── ERC721_ex2.cairo
└── utils.py
El ejercicio nos dice que el evaluador verificará si nuestro NFT tiene las características deseadas llamando a la función get_animal_characteristics en nuestro contrato inteligente ERC721, por lo que debemos implementar la función. El ejercicio también nos proporciona un enlace a un archivo de interfaz para que sepamos la firma de la función.

5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
@contract_interface
namespace IExerciseSolution {
    // Breeding function
    func is_breeder(account: felt) -> (is_approved: felt) {
    }
    func registration_price() -> (price: Uint256) {
    }
    func register_me_as_breeder() -> (is_added: felt) {
    }
    func declare_animal(sex: felt, legs: felt, wings: felt) -> (token_id: Uint256) {
    }
    func get_animal_characteristics(token_id: Uint256) -> (sex: felt, legs: felt, wings: felt) {
    }
    func token_of_owner_by_index(account: felt, index: felt) -> (token_id: Uint256) {
    }
    func declare_dead_animal(token_id: Uint256) {
    }
}
Desde el archivo de interfaz podemos ver que la función get_animal_characteristics espera que se le pase un token_id y devolverá el valor de las tres características. La otra firma interesante es declare_animal ya que nos permitirá crear un animal con las características deseadas en primer lugar.

En su estado actual, nuestro contrato inteligente ERC721 nos permite crear un nuevo NFT al exponer directamente la función mint que espera que el tokenId y la dirección del propietario ( to ) del NFT se pasen como argumentos.

src/ERC721_ex2.cairo

@external
func mint{
        pedersen_ptr: HashBuiltin*,
        syscall_ptr: felt*,
        range_check_ptr
    }(to: felt, tokenId: Uint256) {
    Ownable.assert_only_owner();
    ERC721._mint(to, tokenId);
    return ();
}
Debido a que mint no es parte del estándar ERC721, podemos deshacernos de él y reemplazarlo con declare_animal donde podemos definir las características de nuestro NFT. 

@external
func declare_animal{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}(
    sex : felt, legs : felt, wings : felt
) -> (token_id : Uint256) {
    alloc_locals;
    Ownable.assert_only_owner();
}
Solo el propietario del contrato inteligente puede llamar a nuestra nueva función y, en lugar de esperar que se proporcione el tokenId , realizará un seguimiento del último tokenId e incrementará automáticamente su valor cuando se acuñe un nuevo animal. Mientras estamos en eso, voy a alejarme de la convención del caso del camello y usaré el caso de la serpiente en su lugar para nuestras variables, ya que es la convención en El Cairo.

from starkware.starknet.common.syscalls import get_caller_address
from starkware.cairo.common.uint256 import Uint256, uint256_add
...
 
@storage_var
func last_token_id() -> (token_id : Uint256) {
}
...
 
@external
func declare_animal{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}(
    sex : felt, legs : felt, wings : felt
) -> (token_id : Uint256) {
    alloc_locals;
    Ownable.assert_only_owner();
 
    // Increment token_id by 1
    let current_token_id : Uint256 = last_token_id.read();
    let one_as_uint256 = Uint256(1, 0);
    let (local new_token_id, _) = uint256_add(current_token_id, one_as_uint256);
 
    let (sender_address) = get_caller_address();
 
    // Mint NFT and update token_id
    ERC721._mint(sender_address, new_token_id);
    last_token_id.write(new_token_id);
 
    return (token_id=new_token_id);
}
Usando la biblioteca uint256 podemos definir valores similares a Solidity y realizar operaciones aritméticas simples como sumar o restar. Para rastrear el último valor de token_id , hemos creado una nueva variable de almacenamiento llamada last_token_id que nos encargamos de actualizar cada vez que se acuña un nuevo NFT. Para asegurarnos de que nuestra nueva variable de almacenamiento se inicialice correctamente, agreguemos algunas funciones adicionales al constructor.

...
@constructor
func constructor{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}(
    name : felt, symbol : felt, owner : felt
) {
    ERC721.initializer(name, symbol);
    Ownable.initializer(owner);
    token_id_initializer();
    return ();
}
 
...
func token_id_initializer{pedersen_ptr : HashBuiltin*, syscall_ptr : felt*, range_check_ptr}() {
    let zero_as_uint256 : Uint256 = Uint256(0, 0);
    last_token_id.write(zero_as_uint256);
    return ();
}
De forma predeterminada, el propietario de un nuevo NFT de animales será el propietario del contrato inteligente que actuará como autor de la llamada. Lo único que falta ahora es preocuparse por almacenar las características de nuestros NFT. Para ese propósito, podemos crear un tipo de datos Animal usando una estructura .

...
struct Animal {
    sex : felt
    legs : felt
    wings : felt
}
 
@storage_var
func animals(token_id : Uint256) -> (animal : Animal) {
}
...
 
@external
func declare_animal{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}(
    sex : felt, legs : felt, wings : felt
) -> (token_id : Uint256) {
    alloc_locals;
    Ownable.assert_only_owner();
 
    // Increment token id by 1
    let current_token_id : Uint256 = last_token_id.read();
    let one_as_uint256 = Uint256(1, 0);
    let (local new_token_id, _) = uint256_add(current_token_id, one_as_uint256);
 
    let (sender_address) = get_caller_address();
 
    // Mint NFT and store characteristics on-chain
    ERC721._mint(sender_address, new_token_id);
    animals.write(new_token_id, Animal(sex=sex, legs=legs, wings=wings));
 
    // Update and return new token id
    last_token_id.write(new_token_id);
    return (token_id=new_token_id);
}
Nuestra función declare_animal ahora está completa, podemos cambiar nuestra atención al desarrollo de la función @view get_animal_characteristics .

from starkware.cairo.common.uint256 import Uint256, uint256_add, uint256_check
...
@view
func get_animal_characteristics{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}(
    token_id : Uint256
) -> (sex : felt, legs : felt, wings : felt) {
    with_attr error_message("ERC721: token_id is not a valid Uint256") {
        uint256_check(token_id);
    }
    let animal = animals.read(token_id);
    let animal_ptr = castt(&animal, Animal*);
    return (sex=animal_ptr.sex, legs=animal_ptr.legs, wings=animal_ptr.wings);
}
Nota: Extrañamente, el editor de código de mi blog se rompe cuando uso la palabra cast , así que estoy usando la versión mal escrita castt para evitar que mi blog se bloquee.

Al comienzo de nuestra función, validamos que el token_id proporcionado sea, de hecho, un número uint256 válido, ya que siempre es una buena práctica desinfectar nuestras entradas para evitar ataques inesperados. Después de eso, la función es sencilla excepto por la línea resaltada. El valor que sale de la variable de almacenamiento de animales es simplemente una dirección de memoria, no un puntero. Para convertir esa dirección de memoria en un puntero, tenemos que usar el operador & . De forma predeterminada, el compilador no sabría qué tipo de puntero es este, por lo que para informarle del tipo tenemos que usar la función cast y proporcionar el tipo como segundo argumento ( Animal* ).

Nuestro nuevo contrato inteligente ERC721 está completo, por lo que estamos listos para compilarlo e implementarlo en Goerli.

$ starknet-compile src/ERC721_ex2.cairo --output comp/ERC721_ex2.json
$ starknet deploy --contract comp/ERC721_ex2.json \
  --inputs 71942470984044 4279881 4862… --network alpha-goerli --no_wallet
>>>
Deploy transaction was sent.
Contract address: 0x0581c5f6b97da0132759a6502156624d4b893c75eaca11e333dde1a4383f608d
Transaction hash: 0x211ca20951f29e1ff32fefd7a2aeab1969f4e01aa19afcbbfb46236c2cf84d0
Para acuñar el NFT podemos interactuar con nuestro contrato inteligente en Voyager ( 0x0581… ) y llamar a la función declare_animal pasando los valores solicitados por el Evaluador para nuestro animal.

Acuñar un animal NFT
Acuñar un animal NFT
Una vez que se completa la transacción, podemos verificar que nuestro NFT se creó llamando a la función de vista get_animal_characteristics con token_id 1.

Lectura de las características de un NFT
Lectura de las características de un NFT
En teoría, todo funciona bien, por lo que podemos pasar al siguiente paso y enviar nuestro contrato inteligente ERC721 al Evaluador ( 0x06d2... ) usando la función submit_exercise .

Envío del ejercicio 2 para su evaluación
Envío del ejercicio 2 para su evaluación
Una vez procesada la transacción podemos verificar si completamos el ejercicio llamando a la función ex2a_get_animal_rank .

Validación de que Evaluator puede obtener las características de los animales
Validación de que Evaluator puede obtener las características de los animales
Si el evaluador pudo obtener la información sobre el NFT de nuestro contrato inteligente, ahora deberíamos recibir dos puntos adicionales en el contrato inteligente del contador de punteros ( 0x00a0… ).

Ejercicio 2 validado con éxito
Ejercicio 2 validado con éxito
De hecho, ahora nuestra billetera de prueba en Argent X tiene 8 puntos, 2 más que antes. Hemos completado con éxito el ejercicio 2.

Para ver la implementación final del token ERC721 para el ejercicio 2, vaya a mi repositorio de GitHub .